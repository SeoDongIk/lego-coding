# 코드

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
```

일단 백준의 모든 코드는 저 Main 클래스를 받는다고 한다. 왜 그러지? 일단 넘어가고. 
public static void main(String[] args)는 뭘까. jvm이 호출하는 메서드다. 
결국 이 프로그램은 jvm 위에서 돌아가는 함수일 뿐이다. args는 jvm이 저 자바 파일을 실행할 때, 
넘겨주는 인수일 뿐. 여하튼 그렇고, System은 클래스임. 우리가 가져다 쓸 수 있는 클래스임.
out은 정적 변수임. 변수. 거기 안에는 PrintStream 타입의 변수가 있음. jvm이 실행될 때, 
초기화되어서 만들어져 있음. 이미 저 프로그램을 실행하기도 전에 이미 만들어져있는 객체들이 있는셈. 
어떤 객체들이 존재하고 있을까 그럼? 결국 jvm이 실행되는 것이고 저 Main 클래스를 로딩하기 전에,
다른 클래스들이 먼저 로딩됨. JVM이 먼저 로딩하는 핵심 클래스들이 있음. 
Object, String, System, Class, Thread 같은 것들은 미리 로딩되어 있음.
여기서 유용하게 쓸 수 있는 것들이 있는데 다음과 같음. 

일단 Object 클래스가 있음. 이건 모든 클래스의 최상위 부모임. 기본적으로 equals() 메서드는
두 객체가 같은 메모리 주소를 가리키는지를 비교함. 하지만 알고리즘 문제를 풀 때는, 객체의 내용이 같으면
같은 것으로 판단해야 하는 경우가 많음. 이런 경우에 equals() 메서드를 재정의해서 객체가 논리적으로
같은지를 비교하도록 바꿈. 

또 hashCode() 메서드는 객체를 해시 기반 자료구조(HashMap, HashSet 둘 다 구현체임)에서 빠르게 찾기
위한 정수 해시 값을 반환함. equals()가 true를 반환하는 두 객체는 반드시 hashCode()가 같아야 함. 
따라서 Map이나 Set 인터페이스를 쓸 때, 반드시 equals()랑 hashCode()를 손보아야 함. 
상식적으로 그렇게 해야 똑바로 작동하겠지. 예를 들어 2차원 좌표를 나타내는 Point 클래스를 해시맵의 키로
쓰려면 다음과 같이 정의해야함. 

```java
class Point {
int x, y;

    Point(int x, int y) {
        this.x = x; this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point)) return false;
        Point p = (Point) o;
        return x == p.x && y == p.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }
}
```

저 위에거 졸라 연습하셈. 실재로 쓰임. 

toString은 객체 자체를 문자열로 바꿀 때 씀. 코테에서 쓸 일이 있는지는 잘 모르겠으나, 
결국 우리가 리스트나 셋이나 맵이나 뭐든 출력할 때 저 함수가 호출되는거임. 어쨌든 무의식적으로
자주 쓰는 함수라는 것. clone()은 얕은 복사를 수행하는 함수인데 알고리즘 테스트에서 쓸 일이 잘 없는듯.
참조값 자체가 복사되고, 아 그리고 clone()은 기본적으로 protected라 오버라이딩해야 쓸 수 있음.
당연히 equals, hashCode 다름. 

Class 클래스는 런타임에 클래스 정보를 다루는 메타클래스임. 즉 클래스를 객체처럼 다루게 해주는 클래스임.
getName은 클래스의 이름을 문자열로 반환함. getMethods()는 public 메서드 정보 전첼을 배열로 반환함.
newInstance()는 인스턴스를 동적으로 생성함. 매개변수 없는 생성자만 호출 가능함. 지금은 
getDeclaredConstructor().newInstance()이런 식으로 씀. 

```java
Class<?> clazz = StringBuilder.class;
Object obj = clazz.getDeclaredConstructor().newInstance();
System.out.println(obj instanceof StringBuilder); // true
```

String 클래스도 미리 로드되어 있는 클래스임. 일단 "" 이건 생성자임. String 인스턴스를 만드는 생성자.
new String() 이것도 알아두어야 함. char[] 배열을 인자로 받아서 String 클래스 인스턴스를 생성할 수 있음.
.valueOf() 이건 byte, short, int, long, float, double을 String 클래스로 바꿈.
그리고 + 도 함수임. 이건 string 인스턴스들을 받아 새로운 String 인스턴스를 만드는 팩토리 느낌의 함수임.
가장 중요한 점은 byte, short, int, long, float, double과 같이 쓰일 수 있음. 자동으로 valueOf()가
적용됨. 적용된다음에 합쳐서 새로운 String 인스턴스 만듬. String은 불변임. 그래서 이런 식으로 수정해야함.
생성자나 팩토리 함수들이 졸라 중요함. 물론 값을 수정할 수는 있지만, ""역시도 새로운 인스턴스를 반환할 뿐임. 
String.replace(char oldChar, char newChar)도 마찬가지임. 수정되는게 아니라 이 역시 팩토리 함수임.
참고로 string의 equals()와 hashCode()는 오버라이딩 되어 있음. 문자열이 같은 문자열이면 똑같음.
따라서 동등성 비교를 할 수가 있음. 핵심임. 

length() 길이를 구하는 함수임. charAt(int index) 이건 특정 위치의 문자를 구함. char 반환함. 
indexOf(char c), lastIndexOf(char c) 문자열을 받아서 char[] 배열을 탐색하는 것임. 
요즘에는 byte 배열이지만, 근본적으로는 char 배열로 되어 있음. String 내부 구조가 그럼. 
문자열을 받아서 탐색한 다음에 배열 인덱스를 반환하는 거임. 전자는 앞에서부터 찾아서 반환.
후자는 뒤에서부터 찾아서 반환. 

substring(int start, int end)는 배열 잘라서 반환하는 것임. 그런데 이것도 결국 팩토링함수임. 
그 배열로 새 string 만들어서 반환하는 것! replace(char oldChar, char newChar)는
문자열의 특정 문자를 다른 문자로 변경함. 배열의 요소를 set하는 것. 배열을 모두 탐색함. 

contains()는 문자열이 포함되어 있는지를 확인함. 배열의 요소들을 비교하는 방식일 것. 
split(String regex)는 문자열을 쪼개서 배열로 변환함. 문자열 자체의 배열인 것이 중요함. 이것도
결국 다른 의미의 팩토리 함수임. trim()역시 팩토리 함수. 공백을 빼고 배열을 다시 만드는 것.

toUpperCase(), toLowerCase()는 결국 배열의 요소들을 일정한 형태로 바꿔서 새로운 string을 만드는 것. 

toCharArray()는 문자열을 문자의 배열로 변경함. 

startsWith(String str), endsWith(String str)은 결국 동등성 비교임. 새로운 스트링을 만들어서
동등성 비교를 하는 것. false 아니면 true임. 

다음으로 가장 복잡한 replaceAll(String regex, String replacement)임. 
정규표현식에 매치디는 부분 문자열을 새로운 문자열로 교체함. 매치된 모든 부분을 교체하는 것이 특징임. 

String s = "banana";
System.out.println(s.replaceAll("a", "o"));
// 출력: bonono

String s = "apple";
System.out.println(s.replaceAll("[ap]", "z"));
// 출력: zzlzle

String s = "room 101, floor 3";
System.out.println(s.replaceAll("\\d", ""));
// 출력: room , floor 

String s = "(010) 1234-5678";
System.out.println(s.replaceAll("[^0-9]", ""));
// 출력: 01012345678

String s = "   hello world   ";
System.out.println(s.replaceAll("\\s", ""));
// 출력: helloworld

String s = "Hello     world   !";
System.out.println(s.replaceAll("\\s+", " "));
// 출력: Hello world !

String s = "apple123";
System.out.println(s.replaceAll("[aeiou]", "_"));
// 출력: _ppl_123

String s = "Hello! How are you? :)";
System.out.println(s.replaceAll("[!?:)]", ""));
// 출력: Hello How are you 

String s = "red green blue green red";
System.out.println(s.replaceAll("green", "yellow"));
// 출력: red yellow blue yellow red

String s = "user@example.com";
System.out.println(s.replaceAll("@.*", "@mydomain.com"));
// 출력: user@mydomain.com

String s = "<div>Hello <b>world</b></div>";
System.out.println(s.replaceAll("<[^>]*>", ""));
// 출력: Hello world

String s = "2023-07-09";
System.out.println(s.replaceAll("(\\d{4})-(\\d{2})-(\\d{2})", "$3/$2/$1"));
// 출력: 09/07/2023

| 정규표현식     | 설명                |
| --------- | ----------------- |
| `[aeiou]` | 모음 하나             |
| `\\d`     | 숫자 하나             |
| `[^0-9]`  | 숫자가 아닌 문자         |
| `\\s`     | 공백 문자 (스페이스, 탭 등) |
| `.`       | 모든 문자 1개          |
| `<[^>]*>` | HTML 태그           |

String ssn = "900101-1234567";
System.out.println(ssn.replaceAll("(?<=\\d{6})-\\d{7}", "-*******"));
// 출력: 900101-*******

String phone = "010-1234-5678";
System.out.println(phone.replaceAll("\\d{4}-\\d{4}", "****-****"));
// 출력: 010-****-****

String messy = "주소: 서울시 강남구, 우편번호: 06236";
System.out.println(messy.replaceAll("[^0-9]", ""));
// 출력: 06236

String input = "Hello 123 안녕하세요!!";
System.out.println(input.replaceAll("[^가-힣]", ""));
// 출력: 안녕하세요

String html = "<h1>제목</h1><p>내용입니다</p>";
System.out.println(html.replaceAll("<[^>]+>", ""));
// 출력: 제목내용입니다

String raw = "이것은     테스트 문장 입니다.";
System.out.println(raw.replaceAll("\\s+", " ").trim());
// 출력: 이것은 테스트 문장 입니다.

String id = "user_123!";
System.out.println(id.replaceAll("[^a-zA-Z0-9]", ""));
// 출력: user123

String price = "$12,345원";
System.out.println(price.replaceAll("[^0-9]", ""));
// 출력: 12345

String date = "2024-12-31";
System.out.println(date.replaceAll("-", ""));
// 출력: 20241231

String money = "1,234,567";
System.out.println(money.replaceAll(",", ""));
// 출력: 1234567

String lines = "사과\n바나나\n포도";
String[] arr = lines.split("\n");
for (int i = 0; i < arr.length; i++) {
System.out.println((i + 1) + ". " + arr[i]);
}
// 출력:
// 1. 사과
// 2. 바나나
// 3. 포도

String url = "https://www.example.com";
System.out.println(url.replaceAll("^https?://", ""));
// 출력: www.example.com

String dirty = "문자열@#에는$%^&특수문자가*()많아요!";
System.out.println(dirty.replaceAll("[^a-zA-Z0-9가-힣 ]", ""));
// 출력: 문자열에는특수문자가많아요

| 상황      | 예시                    |
| ------- | --------------------- |
| 마스킹     | 주민번호, 전화번호, 이메일       |
| 데이터 정제  | 숫자 추출, 특수문자 제거, 공백 제거 |
| 파싱      | 날짜, 금액, ID 등          |
| HTML 제거 | 크롤링/스크래핑 후            |
| 포맷 변환   | 날짜, 금액 등              |
| 유효성 보정  | 이메일 도메인, URL          |

다음은 System 클래스다. 이것들 역시 미리 로드된다. 
System.in은 InputStream 객체다. 자바 프로그램이 외부로부터 데이터를 입력받을 수 있게 해주는 표준
입력 스트림이다. InputStream은 특히, 바이트 기반의 입력 스트림이다. 즉, 데이터를 1바이트씩 읽는 방식.
System.in은 사용자의 키보드 입력을 바이트 단위로 받아오는 통로라고 볼 수 있다.
하지만 int b = System.in.read(); 이렇게 직접적으로 쓰는 방식은 바이트 하나씩만 읽기 때문에
매우 불편하다. 그래서 보통 Scanner, BufferedReader와 함꼐 사용한다. 

Scanner sc = new Scanner(System.in); // System.in을 감싸서 편하게 입력 받음
int num = sc.nextInt();

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line = br.readLine();  // 한 줄 입력

이런 식으로 쓴다. InputStreamReader는 바이트 스트림을 문자 스트림으로 바꿔주는 클래스다. 

br.readLine() 이런 식으로 많이 씀. System.out은 println() 이 함수를 많이 씀. 
BufferedWriter를 쓰는 것도 방법임. 

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

이런 식으로도 가능함. 
